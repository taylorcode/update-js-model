{"version":3,"sources":["update-model.js"],"names":[],"mappings":";;QAAgB,WAAW,GAAX,WAAW;;;;;AAApB,SAAS,WAAW,CAAE,MAAM,EAAE,MAAM,EAAE;;AAE1C,OAAG,MAAM,CAAC,WAAW,KAAK,MAAM,CAAC,WAAW,EAAE;AAC3C,YAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAA;IACjF;AACD,OAAG,CAAC,MAAM,YAAY,MAAM,EAAE;AAC3B,YAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAA;IACvE;;AAED,YAAS,oBAAoB,CAAC,GAAG,EAAE;;AAEhC,UAAG,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;AACd,eAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAA;OAC3B;;AAED,aAAG,MAAM,CAAC,GAAG,CAAC,CAAC,WAAW,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC,WAAW,IAAI,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,EAAE;AACtF,uBAAW,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAA;UACvC,MAED,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,GAAG,CAAC,EAAE;;AAC9B,kBAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAA;UAC3B;IACH;;AAED,OAAG,MAAM,YAAY,KAAK,EAAE;;AAEzB,UAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE;AAC/B,eAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM;AAAA,UAAA;OAC/B;;AAED,WAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACpC,6BAAoB,CAAC,CAAC,CAAC,CAAA;OACzB;IACH,MAAM;;;AAGJ,WAAI,IAAI,OAAO,IAAI,MAAM,EAAE;AACxB,aAAG,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;AACjC,mBAAO,MAAM,CAAC,OAAO,CAAC,CAAA;UACxB;OACH;;AAED,WAAI,IAAI,IAAI,IAAI,MAAM,EAAE;AACrB,6BAAoB,CAAC,IAAI,CAAC,CAAA;OAC5B;IACH;CACH","file":"update-model.js","sourcesContent":["export function updateModel (oldObj, newObj) {\n\n   if(oldObj.constructor !== newObj.constructor) {\n      throw new Error('updateModel: both arguments passed must be of the same type.')\n   }\n   if(!oldObj instanceof Object) {\n      throw new Error('updateModel: arguments passed cannot be primitive.')\n   }\n\n   function compareElementsAtKey(key) {\n      // property simply doesn't exist in the new object\n      if(!oldObj[key]) {\n         oldObj[key] = newObj[key]\n      } else\n      // they are both either arrays or hashes, and are not of primitive types\n      if(oldObj[key].constructor === newObj[key].constructor && oldObj[key] instanceof Object) {\n         updateModel(oldObj[key], newObj[key])\n      } else\n\n      if (oldObj[key] !== newObj[key]) { // all this compares is if primitives are equal, don't reassign\n         oldObj[key] = newObj[key]\n      }\n   }\n\n   if(oldObj instanceof Array) {\n      // we can assume at this point that they are both arrays\n      if(oldObj.length > newObj.length) {\n         oldObj.length = newObj.length // actually mutate the length of the old object -- remove the items that are not in it\n      }\n      // the lengths are the same - one to one with new and old object\n      for(var i = 0; i < newObj.length; i++) {\n         compareElementsAtKey(i)\n      }\n   } else {\n      // we can assume that they are both objects\n      // if the old object has any properties that are not in the new object, remove them\n      for(var oldProp in oldObj) {\n         if(!newObj.hasOwnProperty(oldProp)) {\n            delete oldObj[oldProp]\n         }\n      }\n      // now the properties are the same between new and old object\n      for(var prop in newObj) {\n         compareElementsAtKey(prop)\n      }\n   }\n}\n"],"sourceRoot":"/source/"}